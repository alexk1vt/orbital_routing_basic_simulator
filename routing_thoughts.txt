routing thoughts:

24MAY
description of spherical geometry:
https://en.wikipedia.org/wiki/Spherical_geometry

distance between two points on spherical plane:
https://eclipse2017.nasa.gov/crow-flies-spherical-planet#:~:text=The%20shortest%20distance%20between%20any,the%20center%20of%20the%20sphere.

direction of one point to another:
- I think I already have this solved under the 'bearing' functions

so I want to minimize the distance from current location to destination
- two directions will minimize, two will not

what does DiScoRoute do?
- takes geodesic geometry to reduce the routing between two satellites to a rectangle on a curve (where source and destinatino are on opposite corners)
  + this allows author to identify minimum number of hops
  + also able to reduce problem to directed acyclic graph - there are faster algorithms than dijkstra when using DAG

Random route:
- knows two acceptable directions, knows number of hops in which direction
- do they specify on how they calculate number of hops?
  + assuming it's a matter of taking angle from source and destination in lat and lon and dividing by angle distance between sats

** NOTE **:
this paper states that dijkstra doesn't always use minimum hops, just min distance
 - I can do a min-hop version of dijkstra

This is fine, becaues it still sounds like centrally calculated 
  - focus on dynamic!
    > this will be more like the random calculation!
      + still pre-compute max number of hops in either direction, but include that as a weight

Dynamic routing weights:
- max hop count in either direction
  + actually, weigh interfaces based on whether they are going in proper direction or not - don't worry about hop count
- link congestion
- link distance
- recent link status

sat's should already know:
- ground track lat/lon
- direction (NE/NW/SE/SW) of all available interfaces

dynamic route direction:
- know lat/lon of destination terminal
- do simple test as to which 


try to find a way to improve by pre-computing on sending side... (hybrid...)
- maybe use directed routing until a target link is no longer preferred (either down, has too bad of a history, or is too congested), then switch to dynamic?

Try to focus on always trying to minimize
- just calc value based on each interface and choose lowest value


this routing isn't like standard network routing where a target network is identified and there is either a default path to forward unknown traffic or another router says it knows how to get somewhere

options:
- treat individual satellites as destination networks (target satellite is pre-computed at ground station based on destination termianl location)
  + because satellite footprint constantly change, satellites couldn't cache satellites based on destinatino terminal id for more than a few minutes (if that).  But so long as ground station has latest TLEs (or equivelients), no problem
  + however, satellite neighbors don't really change in walker-delta constellations (verify) except for following cases:
    > at latitude extremes, satellite orientation blocks connections to satellites of neighboring orbits (generally, i guess this could be overcome through hardware design)
    > port / starboard nieghbors switch depending on whether ascending/descending (neighboring orbits never change E/W orientation, just the direction the satellites are facing (N/S))
      * NOTE: it is likely there is less bandwidth hopping between orbits than hopping within orbit (due to constantly shifting neighbor orientation)  - might want to factor this into routing tables (rather than fixed value, expected bandwidth would be a function of altitude 
  + knowing this, what could dynamic routing leverage?
    > can build link state tables
      * not just neighbors, but probably neighbors' neighbors, etc...
      * what would change periodically not based on orbital position?
        # link up/down (maybe average BER?)
        # link congestion (once threshold hit)
    > references:
      * every routing in an autonomous system (AS) knows the state of all other routers (https://www.metaswitch.com/knowledge-center/reference/what-is-open-shortest-path-first-ospf#:~:text=The%20OSPF%20protocol%20is%20a,the%20topology%20of%20the%20AS.)
      * link state packets:  https://en.wikipedia.org/wiki/Link_state_packet#:~:text=Link%20State%20Packet%20(LSP)%20is,neighboring%20routers%20and%20associated%20networks.
      * congestion control stuff
        # https://sites.google.com/a/ncsu.edu/congestion-based-ospf/
        # https://www.sciencedirect.com/science/article/pii/S1319157812000195


Routing table options:
- satellites can maintain a table of all satellites in constellation (this is known and doesn't change frequently)
- when a satellite state / link state changes, that gets advertised (via flood) to all other satellites
  + however, when there are frequent / many changes, this can create backlog, consume bandwidth/computation, issues, etc...
- try just neighbor of neighbor (n^2)
  + ideally will localize frequent/numerous changes and not flood network
  + still allow traffic to route around (maybe)
  + what about issues occurring at latitude extremes (inability/reduced ability for inter-orbit links)?  Does n^2 provide enough range to route traffic around it?

How to build scenarios:
- queue up data packets for each interval (1 second interval?) and send
- satellites will have ability to transmit specific number of packets during each interval from specific interfaces (determined by the link bandwidth)
- if packet count exceeds packet bandwidth, a backlog will start
  + satellites will have fixed backlog sizes - any packets that would exceed that size are dropped
- maintian log of packets being sent and verify if they arrived, along with time, number of hops, etc...
** ensure transmission to ground terminal is also considered - bandwidth will vary based on distance / angle of inclination


Scenarios:
- find most congested internet traffic flows (geographically) and replicate


Ways I can impact scenarios:
- satellites can be down
- interfaces can be down (fore, aft, port, starboard)


27 MAY
- directed routing isn't clocking packets received
- also: ensure packets dropped covers all sub-categories so packets_received+packets_dropped always equals packets_sent!

There are still some cases where distributed routing gets caught in a routing loop -- how to prevent?
I think there are also cases when dijkstra can't find a route, which is odd...

Implement the distaster schedule!